// Code generated by gitverse-codegen. DO NOT EDIT.

package gitverse

import (
	"context"
	"fmt"
	"net/url"
)

// Get Get repository details
func (c *Client) Get(ctx context.Context, owner string, repo string) (Repository, error) {
	path := fmt.Sprintf("/repos/%s/%s", owner, repo)
	resp, err := c.get(ctx, path, nil)
	if err != nil {
		var zero Repository
		return zero, err
	}
	return decodeResponse[Repository](resp)
}

// Update Update repository
func (c *Client) Update(ctx context.Context, owner string, repo string, params UpdateRepositoryParams) (Repository, error) {
	path := fmt.Sprintf("/repos/%s/%s", owner, repo)
	resp, err := c.patch(ctx, path, params)
	if err != nil {
		var zero Repository
		return zero, err
	}
	return decodeResponse[Repository](resp)
}

// Delete Delete repository
func (c *Client) Delete(ctx context.Context, owner string, repo string) error {
	path := fmt.Sprintf("/repos/%s/%s", owner, repo)
	resp, err := c.delete(ctx, path, nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		return parseAPIError(resp)
	}
	return nil
}

// ListRepoSecrets Gets a list of repository secrets
func (c *Client) ListRepoSecrets(ctx context.Context, owner string, repo string, opts *QueryOptions) (SecretList, error) {
	path := fmt.Sprintf("/repos/%s/%s/actions/secrets", owner, repo)
	query := url.Values{}
	if opts != nil {
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero SecretList
		return zero, err
	}
	return decodeResponse[SecretList](resp)
}

// GetRepoSecret Gets secrets metadata (without values) in repositories.
func (c *Client) GetRepoSecret(ctx context.Context, owner string, repo string, secretname string) (Secret, error) {
	path := fmt.Sprintf("/repos/%s/%s/actions/secrets/%s", owner, repo, secretname)
	resp, err := c.get(ctx, path, nil)
	if err != nil {
		var zero Secret
		return zero, err
	}
	return decodeResponse[Secret](resp)
}

// CreateOrUpdateRepoSecret Creates or updates a secret in the repository, without
// encryption
func (c *Client) CreateOrUpdateRepoSecret(ctx context.Context, owner string, repo string, secretname string, opts *QueryOptions) (Secret, error) {
	path := fmt.Sprintf("/repos/%s/%s/actions/secrets/%s", owner, repo, secretname)
	query := url.Values{}
	if opts != nil {
		if opts.EncryptedValue != "" {
			query.Set("encrypted_value", opts.EncryptedValue)
		}
	}
	resp, err := c.put(ctx, path, nil)
	if err != nil {
		var zero Secret
		return zero, err
	}
	return decodeResponse[Secret](resp)
}

// DeleteRepoSecret Removes a secret from the repository
func (c *Client) DeleteRepoSecret(ctx context.Context, owner string, repo string, secretname string) error {
	path := fmt.Sprintf("/repos/%s/%s/actions/secrets/%s", owner, repo, secretname)
	resp, err := c.delete(ctx, path, nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		return parseAPIError(resp)
	}
	return nil
}

// ListBranches List repository branches
func (c *Client) ListBranches(ctx context.Context, owner string, repo string, opts *QueryOptions) ([]Branch, error) {
	path := fmt.Sprintf("/repos/%s/%s/branches", owner, repo)
	query := url.Values{}
	if opts != nil {
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Q != "" {
			query.Set("q", opts.Q)
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero []Branch
		return zero, err
	}
	return decodeResponse[[]Branch](resp)
}

// ListCollaborators List repository collaborators
func (c *Client) ListCollaborators(ctx context.Context, owner string, repo string, opts *QueryOptions) ([]Collaborator, error) {
	path := fmt.Sprintf("/repos/%s/%s/collaborators", owner, repo)
	query := url.Values{}
	if opts != nil {
		if opts.Affiliation != "" {
			query.Set("affiliation", opts.Affiliation)
		}
		if opts.Permission != "" {
			query.Set("permission", opts.Permission)
		}
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero []Collaborator
		return zero, err
	}
	return decodeResponse[[]Collaborator](resp)
}

// AddCollaborator Add or update repository collaborator
func (c *Client) AddCollaborator(ctx context.Context, owner string, repo string, collaborator string, params AddCollaboratorParams) (CollaboratorInvitation, error) {
	path := fmt.Sprintf("/repos/%s/%s/collaborators/%s", owner, repo, collaborator)
	resp, err := c.put(ctx, path, params)
	if err != nil {
		var zero CollaboratorInvitation
		return zero, err
	}
	return decodeResponse[CollaboratorInvitation](resp)
}

// ListCommits Retrieve a list of repository commits
func (c *Client) ListCommits(ctx context.Context, owner string, repo string, opts *QueryOptions) ([]Commit, error) {
	path := fmt.Sprintf("/repos/%s/%s/commits", owner, repo)
	query := url.Values{}
	if opts != nil {
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Sha != "" {
			query.Set("sha", opts.Sha)
		}
		if opts.Path != "" {
			query.Set("path", opts.Path)
		}
		if opts.Not != "" {
			query.Set("not", opts.Not)
		}
		if opts.Author != "" {
			query.Set("author", opts.Author)
		}
		if opts.Committer != "" {
			query.Set("committer", opts.Committer)
		}
		if opts.Since != "" {
			query.Set("since", opts.Since)
		}
		if opts.Until != "" {
			query.Set("until", opts.Until)
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero []Commit
		return zero, err
	}
	return decodeResponse[[]Commit](resp)
}

// GetCommit Retrieve commit information
func (c *Client) GetCommit(ctx context.Context, owner string, repo string, sha string) (Commit, error) {
	path := fmt.Sprintf("/repos/%s/%s/commits/%s", owner, repo, sha)
	resp, err := c.get(ctx, path, nil)
	if err != nil {
		var zero Commit
		return zero, err
	}
	return decodeResponse[Commit](resp)
}

// CompareCommits Compare two branches/tags/commits
func (c *Client) CompareCommits(ctx context.Context, owner string, repo string, basehead string, opts *QueryOptions) (CompareResponse, error) {
	path := fmt.Sprintf("/repos/%s/%s/compare/%s", owner, repo, basehead)
	query := url.Values{}
	if opts != nil {
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero CompareResponse
		return zero, err
	}
	return decodeResponse[CompareResponse](resp)
}

// GetContent Get file or directory contents
func (c *Client) GetContent(ctx context.Context, owner string, repo string, filepath string, opts *QueryOptions) (ContentsResponse, error) {
	path := fmt.Sprintf("/repos/%s/%s/contents/%s", owner, repo, filepath)
	query := url.Values{}
	if opts != nil {
		if opts.Ref != "" {
			query.Set("ref", opts.Ref)
		}
		if opts.Scope != "" {
			query.Set("scope", opts.Scope)
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero ContentsResponse
		return zero, err
	}
	return decodeResponse[ContentsResponse](resp)
}

// CreateOrUpdateFile Create or update file in repository
func (c *Client) CreateOrUpdateFile(ctx context.Context, owner string, repo string, filepath string, params CreateFileParams) (FileCreationResponse, error) {
	path := fmt.Sprintf("/repos/%s/%s/contents/%s", owner, repo, filepath)
	resp, err := c.put(ctx, path, params)
	if err != nil {
		var zero FileCreationResponse
		return zero, err
	}
	return decodeResponse[FileCreationResponse](resp)
}

// DeleteFile Delete file in repository
func (c *Client) DeleteFile(ctx context.Context, owner string, repo string, filepath string, params DeleteFileParams) (FileDeleteResponse, error) {
	path := fmt.Sprintf("/repos/%s/%s/contents/%s", owner, repo, filepath)
	resp, err := c.delete(ctx, path, params)
	if err != nil {
		var zero FileDeleteResponse
		return zero, err
	}
	return decodeResponse[FileDeleteResponse](resp)
}

// CreateFork Fork a repository
func (c *Client) CreateFork(ctx context.Context, owner string, repo string, params CreateForkParams) (Repository, error) {
	path := fmt.Sprintf("/repos/%s/%s/forks", owner, repo)
	resp, err := c.post(ctx, path, params)
	if err != nil {
		var zero Repository
		return zero, err
	}
	return decodeResponse[Repository](resp)
}

// CreateCommit Create a Git commit
func (c *Client) CreateCommit(ctx context.Context, owner string, repo string, params CreateCommitParams) (Commit, error) {
	path := fmt.Sprintf("/repos/%s/%s/git/commits", owner, repo)
	resp, err := c.post(ctx, path, params)
	if err != nil {
		var zero Commit
		return zero, err
	}
	return decodeResponse[Commit](resp)
}

// CreateRef Create a Git reference
func (c *Client) CreateRef(ctx context.Context, owner string, repo string, params CreateReferenceParams) (Reference, error) {
	path := fmt.Sprintf("/repos/%s/%s/git/refs", owner, repo)
	resp, err := c.post(ctx, path, params)
	if err != nil {
		var zero Reference
		return zero, err
	}
	return decodeResponse[Reference](resp)
}

// CreateTree Creates new Git tree
func (c *Client) CreateTree(ctx context.Context, owner string, repo string, params CreateTreeParams) (RepoTree, error) {
	path := fmt.Sprintf("/repos/%s/%s/git/trees", owner, repo)
	resp, err := c.post(ctx, path, params)
	if err != nil {
		var zero RepoTree
		return zero, err
	}
	return decodeResponse[RepoTree](resp)
}

// GetTree Get repository tree by SHA
func (c *Client) GetTree(ctx context.Context, owner string, repo string, sha string, opts *QueryOptions) (GitTreeResponse, error) {
	path := fmt.Sprintf("/repos/%s/%s/git/trees/%s", owner, repo, sha)
	query := url.Values{}
	if opts != nil {
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Recursive {
			query.Set("recursive", "true")
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero GitTreeResponse
		return zero, err
	}
	return decodeResponse[GitTreeResponse](resp)
}

// ListLanguages Get repository languages
func (c *Client) ListLanguages(ctx context.Context, owner string, repo string) (map[string]interface{}, error) {
	path := fmt.Sprintf("/repos/%s/%s/languages", owner, repo)
	resp, err := c.get(ctx, path, nil)
	if err != nil {
		var zero map[string]interface{}
		return zero, err
	}
	return decodeResponse[map[string]interface{}](resp)
}

// ListPulls List pull requests
func (c *Client) ListPulls(ctx context.Context, owner string, repo string, opts *QueryOptions) ([]PullRequest, error) {
	path := fmt.Sprintf("/repos/%s/%s/pulls", owner, repo)
	query := url.Values{}
	if opts != nil {
		if opts.State != "" {
			query.Set("state", opts.State)
		}
		if opts.Head != "" {
			query.Set("head", opts.Head)
		}
		if opts.Base != "" {
			query.Set("base", opts.Base)
		}
		if opts.Sort != "" {
			query.Set("sort", opts.Sort)
		}
		if opts.Direction != "" {
			query.Set("direction", opts.Direction)
		}
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero []PullRequest
		return zero, err
	}
	return decodeResponse[[]PullRequest](resp)
}

// GetPull Pull request details.
func (c *Client) GetPull(ctx context.Context, owner string, repo string, pull_number float64) (PullRequest, error) {
	path := fmt.Sprintf("/repos/%s/%s/pulls/%v", owner, repo, pull_number)
	resp, err := c.get(ctx, path, nil)
	if err != nil {
		var zero PullRequest
		return zero, err
	}
	return decodeResponse[PullRequest](resp)
}

// UpdatePull Update a pull request.
func (c *Client) UpdatePull(ctx context.Context, owner string, repo string, pull_number float64, params UpdatePullRequestParams) (PullRequest, error) {
	path := fmt.Sprintf("/repos/%s/%s/pulls/%v", owner, repo, pull_number)
	resp, err := c.patch(ctx, path, params)
	if err != nil {
		var zero PullRequest
		return zero, err
	}
	return decodeResponse[PullRequest](resp)
}

// ListForAuthenticatedUser Get authenticated user repositories
func (c *Client) ListForAuthenticatedUser(ctx context.Context, opts *QueryOptions) ([]Repository, error) {
	path := "/user/repos"
	query := url.Values{}
	if opts != nil {
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero []Repository
		return zero, err
	}
	return decodeResponse[[]Repository](resp)
}

// CreateForAuthenticatedUser Create repository
func (c *Client) CreateForAuthenticatedUser(ctx context.Context, params CreateRepositoryParams) (Repository, error) {
	path := "/user/repos"
	resp, err := c.post(ctx, path, params)
	if err != nil {
		var zero Repository
		return zero, err
	}
	return decodeResponse[Repository](resp)
}
