// Code generated by gitverse-codegen. DO NOT EDIT.

package gitverse

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"time"
)

// APIError представляет ошибку API
type APIError struct {
	// StatusCode - HTTP статус код
	StatusCode int

	// Message - сообщение об ошибке
	Message string

	// DocumentationURL - URL документации
	DocumentationURL string

	// RequestID - уникальный идентификатор запроса
	RequestID string
}

// Error реализует интерфейс error
func (e *APIError) Error() string {
	if e.Message != "" {
		return fmt.Sprintf("GitVerse API error (status %d): %s", e.StatusCode, e.Message)
	}
	return fmt.Sprintf("GitVerse API error (status %d)", e.StatusCode)
}

// RateLimitError представляет ошибку превышения лимита запросов
type RateLimitError struct {
	*APIError

	// Limit - максимальное количество запросов
	Limit int

	// Remaining - оставшееся количество запросов
	Remaining int

	// Reset - время сброса лимита
	Reset time.Time

	// RetryAfter - через сколько секунд можно повторить запрос
	RetryAfter int
}

// Error реализует интерфейс error
func (e *RateLimitError) Error() string {
	return fmt.Sprintf("rate limit exceeded: retry after %d seconds", e.RetryAfter)
}

// apiErrorResponse структура ответа с ошибкой
type apiErrorResponse struct {
	Message          string `json:"message"`
	DocumentationURL string `json:"documentation_url"`
}

// parseAPIError парсит ошибку из HTTP ответа
func parseAPIError(resp *http.Response) error {
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return &APIError{
			StatusCode: resp.StatusCode,
			Message:    "failed to read error response",
		}
	}

	apiErr := &APIError{
		StatusCode: resp.StatusCode,
		RequestID:  resp.Header.Get("X-Request-Id"),
	}

	// Парсим JSON ответ
	var errResp apiErrorResponse
	if err := json.Unmarshal(body, &errResp); err == nil {
		apiErr.Message = errResp.Message
		apiErr.DocumentationURL = errResp.DocumentationURL
	} else {
		apiErr.Message = string(body)
	}

	// Проверяем на rate limit
	if resp.StatusCode == http.StatusTooManyRequests {
		rateLimitErr := &RateLimitError{APIError: apiErr}

		if limit := resp.Header.Get("GitVerse-RateLimit-Limit"); limit != "" {
			rateLimitErr.Limit, _ = strconv.Atoi(limit)
		}
		// Пробуем оба варианта заголовка
		remaining := resp.Header.Get("GitVerse-RateLimit-User-Remaining")
		if remaining == "" {
			remaining = resp.Header.Get("GitVerse-RateLimit-Remaining")
		}
		if remaining != "" {
			rateLimitErr.Remaining, _ = strconv.Atoi(remaining)
		}
		if reset := resp.Header.Get("Gitverse-Ratelimit-Reset"); reset != "" {
			if ts, err := strconv.ParseInt(reset, 10, 64); err == nil {
				rateLimitErr.Reset = time.Unix(ts, 0)
			}
		}
		if retryAfter := resp.Header.Get("GitVerse-RateLimit-Retry-After"); retryAfter != "" {
			rateLimitErr.RetryAfter, _ = strconv.Atoi(retryAfter)
		}

		return rateLimitErr
	}

	return apiErr
}

// IsNotFound проверяет, является ли ошибка 404 Not Found
func IsNotFound(err error) bool {
	if apiErr, ok := err.(*APIError); ok {
		return apiErr.StatusCode == http.StatusNotFound
	}
	return false
}

// IsRateLimitError проверяет, является ли ошибка превышением лимита
func IsRateLimitError(err error) bool {
	_, ok := err.(*RateLimitError)
	return ok
}

// IsUnauthorized проверяет, является ли ошибка 401 Unauthorized
func IsUnauthorized(err error) bool {
	if apiErr, ok := err.(*APIError); ok {
		return apiErr.StatusCode == http.StatusUnauthorized
	}
	return false
}

// IsForbidden проверяет, является ли ошибка 403 Forbidden
func IsForbidden(err error) bool {
	if apiErr, ok := err.(*APIError); ok {
		return apiErr.StatusCode == http.StatusForbidden
	}
	return false
}
