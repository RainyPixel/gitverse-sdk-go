// Code generated by gitverse-codegen. DO NOT EDIT.

package gitverse

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

const (
	// DefaultBaseURL - базовый URL GitVerse API
	DefaultBaseURL = "https://api.gitverse.ru"

	// DefaultAPIVersion - версия API по умолчанию
	DefaultAPIVersion = "1"

	// DefaultTimeout - таймаут по умолчанию
	DefaultTimeout = 30 * time.Second

	// DefaultUserAgent - User-Agent по умолчанию
	DefaultUserAgent = "github.com/RainyPixel/gitverse-sdk-go"
)

// RateLimitInfo содержит информацию о лимитах запросов
type RateLimitInfo struct {
	// Limit - максимальное количество запросов
	Limit int

	// Remaining - оставшееся количество запросов
	Remaining int

	// Reset - время сброса лимита (Unix timestamp)
	Reset int64

	// RetryAfter - через сколько секунд можно повторить запрос
	RetryAfter int
}

// APIVersionInfo содержит информацию о версии API
type APIVersionInfo struct {
	// Version - текущая версия API
	Version string

	// LatestVersion - последняя доступная версия
	LatestVersion string

	// Deprecated - признак устаревшей версии
	Deprecated bool

	// Decommissioning - дата вывода из эксплуатации
	Decommissioning string
}

// ResponseMetadata содержит метаданные ответа API
type ResponseMetadata struct {
	// RateLimit - информация о лимитах запросов
	RateLimit *RateLimitInfo

	// APIVersion - информация о версии API
	APIVersion *APIVersionInfo
}

// APIVersionWarningHandler - обработчик предупреждений об устаревшей версии API
type APIVersionWarningHandler func(info APIVersionInfo)

// ClientConfig содержит конфигурацию клиента
type ClientConfig struct {
	// BaseURL - базовый URL API (по умолчанию https://api.gitverse.ru)
	BaseURL string

	// Token - токен авторизации
	Token string

	// APIVersion - версия API (по умолчанию "1")
	APIVersion string

	// HTTPClient - HTTP клиент (по умолчанию http.DefaultClient с таймаутом)
	HTTPClient *http.Client

	// UserAgent - User-Agent заголовок
	UserAgent string

	// OnAPIVersionWarning - callback для предупреждений об устаревшей версии API
	OnAPIVersionWarning APIVersionWarningHandler
}

// Client представляет HTTP клиент для GitVerse API
type Client struct {
	baseURL             string
	token               string
	apiVersion          string
	httpClient          *http.Client
	userAgent           string
	onAPIVersionWarning APIVersionWarningHandler
}

// NewClient создаёт новый клиент GitVerse API
func NewClient(config ClientConfig) *Client {
	baseURL := config.BaseURL
	if baseURL == "" {
		baseURL = DefaultBaseURL
	}
	// Убираем trailing slash
	baseURL = strings.TrimSuffix(baseURL, "/")

	apiVersion := config.APIVersion
	if apiVersion == "" {
		apiVersion = DefaultAPIVersion
	}

	httpClient := config.HTTPClient
	if httpClient == nil {
		httpClient = &http.Client{
			Timeout: DefaultTimeout,
		}
	}

	userAgent := config.UserAgent
	if userAgent == "" {
		userAgent = DefaultUserAgent
	}

	return &Client{
		baseURL:             baseURL,
		token:               config.Token,
		apiVersion:          apiVersion,
		httpClient:          httpClient,
		userAgent:           userAgent,
		onAPIVersionWarning: config.OnAPIVersionWarning,
	}
}

// SetToken устанавливает токен авторизации
func (c *Client) SetToken(token string) {
	c.token = token
}

// SetAPIVersionWarningHandler устанавливает обработчик предупреждений о версии API
func (c *Client) SetAPIVersionWarningHandler(handler APIVersionWarningHandler) {
	c.onAPIVersionWarning = handler
}

// RequestOption - опция для кастомизации запроса
type RequestOption func(*http.Request)

// WithHeader добавляет заголовок к запросу
func WithHeader(key, value string) RequestOption {
	return func(req *http.Request) {
		req.Header.Set(key, value)
	}
}

// extractRateLimitInfo извлекает информацию о лимитах из заголовков
func extractRateLimitInfo(headers http.Header) *RateLimitInfo {
	limit := headers.Get("GitVerse-RateLimit-Limit")
	remaining := headers.Get("GitVerse-RateLimit-User-Remaining")
	if remaining == "" {
		remaining = headers.Get("GitVerse-RateLimit-Remaining")
	}
	retryAfter := headers.Get("GitVerse-RateLimit-Retry-After")
	reset := headers.Get("Gitverse-Ratelimit-Reset")

	if limit == "" || retryAfter == "" {
		return nil
	}

	info := &RateLimitInfo{}
	info.Limit, _ = strconv.Atoi(limit)
	info.Remaining, _ = strconv.Atoi(remaining)
	info.RetryAfter, _ = strconv.Atoi(retryAfter)

	if reset != "" {
		info.Reset, _ = strconv.ParseInt(reset, 10, 64)
	} else {
		info.Reset = time.Now().Unix() + int64(info.RetryAfter)
	}

	return info
}

// extractAPIVersionInfo извлекает информацию о версии API из заголовков
func extractAPIVersionInfo(headers http.Header) *APIVersionInfo {
	version := headers.Get("Gitverse-Api-Version")
	latestVersion := headers.Get("Gitverse-Api-Latest-Version")

	if version == "" || latestVersion == "" {
		return nil
	}

	return &APIVersionInfo{
		Version:         version,
		LatestVersion:   latestVersion,
		Deprecated:      headers.Get("Gitverse-Api-Deprecation") == "true",
		Decommissioning: headers.Get("Gitverse-Api-Decommissioning"),
	}
}

// extractMetadata извлекает метаданные из заголовков ответа
func (c *Client) extractMetadata(headers http.Header) *ResponseMetadata {
	metadata := &ResponseMetadata{
		RateLimit:  extractRateLimitInfo(headers),
		APIVersion: extractAPIVersionInfo(headers),
	}

	// Вызываем callback если версия API устарела
	if metadata.APIVersion != nil && metadata.APIVersion.Deprecated && c.onAPIVersionWarning != nil {
		c.onAPIVersionWarning(*metadata.APIVersion)
	}

	return metadata
}

// request выполняет HTTP запрос
func (c *Client) request(
	ctx context.Context,
	method string,
	path string,
	query url.Values,
	body interface{},
	opts ...RequestOption,
) (*http.Response, error) {
	// Правильная конкатенация URL: убираем начальный / из path если он есть
	cleanPath := strings.TrimPrefix(path, "/")
	u := c.baseURL + "/" + cleanPath
	if len(query) > 0 {
		u += "?" + query.Encode()
	}

	// Подготавливаем тело запроса
	var bodyReader io.Reader
	if body != nil {
		jsonBody, err := json.Marshal(body)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal request body: %w", err)
		}
		bodyReader = bytes.NewReader(jsonBody)
	}

	// Создаём запрос
	req, err := http.NewRequestWithContext(ctx, method, u, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Устанавливаем заголовки
	req.Header.Set("User-Agent", c.userAgent)
	req.Header.Set("Accept", fmt.Sprintf("application/vnd.gitverse.object+json; version=%s", c.apiVersion))
	req.Header.Set("Content-Type", "application/json")

	if c.token != "" {
		req.Header.Set("Authorization", "Bearer "+c.token)
	}

	// Применяем опции
	for _, opt := range opts {
		opt(req)
	}

	// Выполняем запрос
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}

	return resp, nil
}

// get выполняет GET запрос
func (c *Client) get(ctx context.Context, path string, query url.Values, opts ...RequestOption) (*http.Response, error) {
	return c.request(ctx, http.MethodGet, path, query, nil, opts...)
}

// post выполняет POST запрос
func (c *Client) post(ctx context.Context, path string, body interface{}, opts ...RequestOption) (*http.Response, error) {
	return c.request(ctx, http.MethodPost, path, nil, body, opts...)
}

// put выполняет PUT запрос
func (c *Client) put(ctx context.Context, path string, body interface{}, opts ...RequestOption) (*http.Response, error) {
	return c.request(ctx, http.MethodPut, path, nil, body, opts...)
}

// patch выполняет PATCH запрос
func (c *Client) patch(ctx context.Context, path string, body interface{}, opts ...RequestOption) (*http.Response, error) {
	return c.request(ctx, http.MethodPatch, path, nil, body, opts...)
}

// delete выполняет DELETE запрос
func (c *Client) delete(ctx context.Context, path string, body interface{}, opts ...RequestOption) (*http.Response, error) {
	return c.request(ctx, http.MethodDelete, path, nil, body, opts...)
}

// UploadFile загружает файл через multipart/form-data
func (c *Client) UploadFile(
	ctx context.Context,
	path string,
	fieldName string,
	fileName string,
	fileContent io.Reader,
	opts ...RequestOption,
) (*http.Response, error) {
	cleanPath := strings.TrimPrefix(path, "/")
	u := c.baseURL + "/" + cleanPath

	// Создаём multipart writer
	var buf bytes.Buffer
	writer := multipart.NewWriter(&buf)

	// Добавляем файл
	part, err := writer.CreateFormFile(fieldName, fileName)
	if err != nil {
		return nil, fmt.Errorf("failed to create form file: %w", err)
	}

	if _, err := io.Copy(part, fileContent); err != nil {
		return nil, fmt.Errorf("failed to copy file content: %w", err)
	}

	if err := writer.Close(); err != nil {
		return nil, fmt.Errorf("failed to close multipart writer: %w", err)
	}

	// Создаём запрос
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, u, &buf)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Устанавливаем заголовки
	req.Header.Set("User-Agent", c.userAgent)
	req.Header.Set("Accept", fmt.Sprintf("application/vnd.gitverse.object+json; version=%s", c.apiVersion))
	req.Header.Set("Content-Type", writer.FormDataContentType())

	if c.token != "" {
		req.Header.Set("Authorization", "Bearer "+c.token)
	}

	// Применяем опции
	for _, opt := range opts {
		opt(req)
	}

	// Выполняем запрос
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}

	return resp, nil
}

// decodeResponse декодирует JSON ответ
func decodeResponse[T any](resp *http.Response) (T, error) {
	var result T
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		return result, parseAPIError(resp)
	}

	// Для пустых ответов (204 No Content)
	if resp.StatusCode == http.StatusNoContent {
		return result, nil
	}

	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return result, fmt.Errorf("failed to decode response: %w", err)
	}

	return result, nil
}
