// Code generated by gitverse-codegen. DO NOT EDIT.

package gitverse

import (
	"context"
	"fmt"
	"net/url"
)

// ListIssues List issues and pull requests
func (c *Client) ListIssues(ctx context.Context, owner string, repo string, opts *QueryOptions) ([]Issue, error) {
	path := fmt.Sprintf("/repos/%s/%s/issues", owner, repo)
	query := url.Values{}
	if opts != nil {
		if opts.State != "" {
			query.Set("state", opts.State)
		}
		if opts.Q != "" {
			query.Set("q", opts.Q)
		}
		if opts.Labels != "" {
			query.Set("labels", opts.Labels)
		}
		if opts.Milestones != "" {
			query.Set("milestones", opts.Milestones)
		}
		if opts.CreatedBy != "" {
			query.Set("created_by", opts.CreatedBy)
		}
		if opts.AssignedBy != "" {
			query.Set("assigned_by", opts.AssignedBy)
		}
		if opts.MentionedBy != "" {
			query.Set("mentioned_by", opts.MentionedBy)
		}
		if opts.Type != "" {
			query.Set("type", opts.Type)
		}
		if opts.Since != "" {
			query.Set("since", opts.Since)
		}
		if opts.Before != "" {
			query.Set("before", opts.Before)
		}
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero []Issue
		return zero, err
	}
	return decodeResponse[[]Issue](resp)
}

// GetIssues Get issue or pull request
func (c *Client) GetIssues(ctx context.Context, owner string, repo string, index float64) (Issue, error) {
	path := fmt.Sprintf("/repos/%s/%s/issues/%v", owner, repo, index)
	resp, err := c.get(ctx, path, nil)
	if err != nil {
		var zero Issue
		return zero, err
	}
	return decodeResponse[Issue](resp)
}

// ListComments List issue comments
func (c *Client) ListComments(ctx context.Context, owner string, repo string, index float64, opts *QueryOptions) ([]Comment, error) {
	path := fmt.Sprintf("/repos/%s/%s/issues/%v/comments", owner, repo, index)
	query := url.Values{}
	if opts != nil {
		if opts.Since != "" {
			query.Set("since", opts.Since)
		}
		if opts.Before != "" {
			query.Set("before", opts.Before)
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero []Comment
		return zero, err
	}
	return decodeResponse[[]Comment](resp)
}

// ListLabels List issue labels
func (c *Client) ListLabels(ctx context.Context, owner string, repo string, index float64) ([]Label, error) {
	path := fmt.Sprintf("/repos/%s/%s/issues/%v/labels", owner, repo, index)
	resp, err := c.get(ctx, path, nil)
	if err != nil {
		var zero []Label
		return zero, err
	}
	return decodeResponse[[]Label](resp)
}

// ListTimeline List issue comments and timeline events
func (c *Client) ListTimeline(ctx context.Context, owner string, repo string, index float64, opts *QueryOptions) ([]TimelineComment, error) {
	path := fmt.Sprintf("/repos/%s/%s/issues/%v/timeline", owner, repo, index)
	query := url.Values{}
	if opts != nil {
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Since != "" {
			query.Set("since", opts.Since)
		}
		if opts.Before != "" {
			query.Set("before", opts.Before)
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero []TimelineComment
		return zero, err
	}
	return decodeResponse[[]TimelineComment](resp)
}

// GetComment Get a specific issue comment
func (c *Client) GetComment(ctx context.Context, owner string, repo string, id float64) (Comment, error) {
	path := fmt.Sprintf("/repos/%s/%s/issues/comments/%v", owner, repo, id)
	resp, err := c.get(ctx, path, nil)
	if err != nil {
		var zero Comment
		return zero, err
	}
	return decodeResponse[Comment](resp)
}
