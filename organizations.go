// Code generated by gitverse-codegen. DO NOT EDIT.

package gitverse

import (
	"context"
	"fmt"
	"net/url"
)

// ListOrgSecrets Gets a list of organization secrets
func (c *Client) ListOrgSecrets(ctx context.Context, org string, opts *QueryOptions) (SecretList, error) {
	path := fmt.Sprintf("/orgs/%s/actions/secrets", org)
	query := url.Values{}
	if opts != nil {
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero SecretList
		return zero, err
	}
	return decodeResponse[SecretList](resp)
}

// GetOrgSecret Gets the metadata of a secret (without value) in an organization
func (c *Client) GetOrgSecret(ctx context.Context, org string, secretname string) (Secret, error) {
	path := fmt.Sprintf("/orgs/%s/actions/secrets/%s", org, secretname)
	resp, err := c.get(ctx, path, nil)
	if err != nil {
		var zero Secret
		return zero, err
	}
	return decodeResponse[Secret](resp)
}

// CreateOrUpdateOrgSecret Creates or updates a secret in the organization, without
// encryption
func (c *Client) CreateOrUpdateOrgSecret(ctx context.Context, org string, secretname string, opts *QueryOptions) (Secret, error) {
	path := fmt.Sprintf("/orgs/%s/actions/secrets/%s", org, secretname)
	query := url.Values{}
	if opts != nil {
		if opts.EncryptedValue != "" {
			query.Set("encrypted_value", opts.EncryptedValue)
		}
	}
	resp, err := c.put(ctx, path, nil)
	if err != nil {
		var zero Secret
		return zero, err
	}
	return decodeResponse[Secret](resp)
}

// DeleteOrgSecret Removes a secret from an organization
func (c *Client) DeleteOrgSecret(ctx context.Context, org string, secretname string) error {
	path := fmt.Sprintf("/orgs/%s/actions/secrets/%s", org, secretname)
	resp, err := c.delete(ctx, path, nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		return parseAPIError(resp)
	}
	return nil
}

// IsMember Check organization membership for a user
func (c *Client) IsMember(ctx context.Context, org string, username string) error {
	path := fmt.Sprintf("/orgs/%s/members/%s", org, username)
	resp, err := c.get(ctx, path, nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		return parseAPIError(resp)
	}
	return nil
}
