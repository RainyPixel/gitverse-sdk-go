// Code generated by gitverse-codegen. DO NOT EDIT.

package gitverse

import (
	"context"
	"fmt"
	"net/url"
)

// ListReleases Returns a list of releases
func (c *Client) ListReleases(ctx context.Context, owner string, repo string, opts *QueryOptions) ([]Release, error) {
	path := fmt.Sprintf("/repos/%s/%s/releases", owner, repo)
	query := url.Values{}
	if opts != nil {
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
		if opts.Draft {
			query.Set("draft", "true")
		}
		if opts.PreRelease {
			query.Set("pre_release", "true")
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero []Release
		return zero, err
	}
	return decodeResponse[[]Release](resp)
}

// CreateReleases Create a release
func (c *Client) CreateReleases(ctx context.Context, owner string, repo string, params CreateReleaseParams) (Release, error) {
	path := fmt.Sprintf("/repos/%s/%s/releases", owner, repo)
	resp, err := c.post(ctx, path, params)
	if err != nil {
		var zero Release
		return zero, err
	}
	return decodeResponse[Release](resp)
}

// GetReleases Return a release
func (c *Client) GetReleases(ctx context.Context, owner string, repo string, release_id string) (Release, error) {
	path := fmt.Sprintf("/repos/%s/%s/releases/%s", owner, repo, release_id)
	resp, err := c.get(ctx, path, nil)
	if err != nil {
		var zero Release
		return zero, err
	}
	return decodeResponse[Release](resp)
}

// UpdateReleases Edit a release
func (c *Client) UpdateReleases(ctx context.Context, owner string, repo string, release_id string, params UpdateReleaseParams) (Release, error) {
	path := fmt.Sprintf("/repos/%s/%s/releases/%s", owner, repo, release_id)
	resp, err := c.patch(ctx, path, params)
	if err != nil {
		var zero Release
		return zero, err
	}
	return decodeResponse[Release](resp)
}

// DeleteReleases Delete a release
func (c *Client) DeleteReleases(ctx context.Context, owner string, repo string, release_id string) error {
	path := fmt.Sprintf("/repos/%s/%s/releases/%s", owner, repo, release_id)
	resp, err := c.delete(ctx, path, nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		return parseAPIError(resp)
	}
	return nil
}

// ListAssets Returns a list of assets (files) for a release
func (c *Client) ListAssets(ctx context.Context, owner string, repo string, release_id string, opts *QueryOptions) ([]Attachment, error) {
	path := fmt.Sprintf("/repos/%s/%s/releases/%s/assets", owner, repo, release_id)
	query := url.Values{}
	if opts != nil {
		if opts.Page != 0 {
			query.Set("page", fmt.Sprintf("%d", opts.Page))
		}
		if opts.PerPage != 0 {
			query.Set("per_page", fmt.Sprintf("%d", opts.PerPage))
		}
	}
	resp, err := c.get(ctx, path, query)
	if err != nil {
		var zero []Attachment
		return zero, err
	}
	return decodeResponse[[]Attachment](resp)
}

// UploadAsset Upload asset to release
func (c *Client) UploadAsset(ctx context.Context, owner string, repo string, release_id string, opts *QueryOptions) (Attachment, error) {
	path := fmt.Sprintf("/repos/%s/%s/releases/%s/assets", owner, repo, release_id)
	query := url.Values{}
	if opts != nil {
		if opts.Name != "" {
			query.Set("name", opts.Name)
		}
	}
	resp, err := c.post(ctx, path, nil)
	if err != nil {
		var zero Attachment
		return zero, err
	}
	return decodeResponse[Attachment](resp)
}

// DeleteAssets Delete asset from release
func (c *Client) DeleteAssets(ctx context.Context, owner string, repo string, release_id string, asset_id string) error {
	path := fmt.Sprintf("/repos/%s/%s/releases/%s/assets/%s", owner, repo, release_id, asset_id)
	resp, err := c.delete(ctx, path, nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		return parseAPIError(resp)
	}
	return nil
}

// GetByTag Gets a release by its tag name
func (c *Client) GetByTag(ctx context.Context, owner string, repo string, tag string) (Release, error) {
	path := fmt.Sprintf("/repos/%s/%s/releases/tags/%s", owner, repo, tag)
	resp, err := c.get(ctx, path, nil)
	if err != nil {
		var zero Release
		return zero, err
	}
	return decodeResponse[Release](resp)
}

// DeleteByTag Deletes a release by its tag name
func (c *Client) DeleteByTag(ctx context.Context, owner string, repo string, tag string) error {
	path := fmt.Sprintf("/repos/%s/%s/releases/tags/%s", owner, repo, tag)
	resp, err := c.delete(ctx, path, nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		return parseAPIError(resp)
	}
	return nil
}
